/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "mibIEEE80222.h"

/* 
 * mibIEEE80222_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid mibIEEE80222_variables_oid[] = { 1,3,6,1,2,1,1300 };

/* 
 * variable4 mibIEEE80222_variables:
 *   this variable defines function callbacks and type return information 
 *   for the mibIEEE80222 mib section 
 */

struct variable4 mibIEEE80222_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define WRANIFSMSSACHAVAILABILITYCHECKTIME		1
{WRANIFSMSSACHAVAILABILITYCHECKTIME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_mibIEEE80222, 2,  { 5,1 }},
#define WRANIFSMSSANONOCCUPANCYPERIOD		2
{WRANIFSMSSANONOCCUPANCYPERIOD,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_mibIEEE80222, 2,  { 5,2 }},
#define WRANIFSMSSACHANNELOPENINGTXTIME		3
{WRANIFSMSSACHANNELOPENINGTXTIME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_mibIEEE80222, 2,  { 5,3 }},
#define WRANIFSMMANAGEDCHANNEL		4
{WRANIFSMMANAGEDCHANNEL,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_mibIEEE80222, 2,  { 5,4 }},
#define WRANIFSMMANAGEDCHANNELSTATUS		5
{WRANIFSMMANAGEDCHANNELSTATUS,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_mibIEEE80222, 2,  { 5,5 }},
#define WRANIFSMWRANOCCUPIEDCHANNELSET		6
{WRANIFSMWRANOCCUPIEDCHANNELSET,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_mibIEEE80222, 2,  { 5,6 }},
#define WRANIFSSASENSINGCHANNEL		7
{WRANIFSSASENSINGCHANNEL,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_mibIEEE80222, 2,  { 6,1 }},
#define WRANIFSSATIMELASTSENSING		8
{WRANIFSSATIMELASTSENSING,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_mibIEEE80222, 2,  { 6,2 }},
#define WRANIFSSASENSINGPATHRSSI		9
{WRANIFSSASENSINGPATHRSSI,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_mibIEEE80222, 2,  { 6,3 }},
#define DECISIONOPERATINGCHANNEL		10
{DECISIONOPERATINGCHANNEL,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_mibIEEE80222, 2,  { 8,1 }},
#define DECISIONBACKUPCHANNEL		11
{DECISIONBACKUPCHANNEL,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_mibIEEE80222, 2,  { 8,2 }},
#define DECISIONCANDIDATECHANNELS		12
{DECISIONCANDIDATECHANNELS,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_mibIEEE80222, 2,  { 8,3 }},
#define DECISIONGAMAWEIGHT		13
{DECISIONGAMAWEIGHT,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_mibIEEE80222, 2,  { 8,4 }},
#define DECISIONRSSIMINVALUE		14
{DECISIONRSSIMINVALUE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_mibIEEE80222, 2,  { 8,5 }},
#define DECISIONRSSIMAXVALUE		15
{DECISIONRSSIMAXVALUE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_mibIEEE80222, 2,  { 8,6 }},
#define DECISIONUPLINKTHROUGHPUT		16
{DECISIONUPLINKTHROUGHPUT,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_mibIEEE80222, 2,  { 8,7 }},
#define DECISIONDOWNLINKTHROUGHPUT		17
{DECISIONDOWNLINKTHROUGHPUT,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_mibIEEE80222, 2,  { 8,8 }},
#define SHARINGSTARTTIME		18
{SHARINGSTARTTIME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_mibIEEE80222, 2,  { 8,9 }},
#define SHARINGSTOPTIME		19
{SHARINGSTOPTIME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_mibIEEE80222, 2,  { 8,10 }},
#define SHARINGALLOCATEDBAND		20
{SHARINGALLOCATEDBAND,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_mibIEEE80222, 2,  { 8,11 }},
#define WRANIFGENERICOBJ1		21
{WRANIFGENERICOBJ1,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_mibIEEE80222, 2,  { 9,1 }},
#define WRANIFGENERICOBJ2		22
{WRANIFGENERICOBJ2,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_mibIEEE80222, 2,  { 9,2 }},
#define WRANIFGENERICOBJ3		23
{WRANIFGENERICOBJ3,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_mibIEEE80222, 2,  { 9,3 }},
#define WRANIFGENERICOBJ4		24
{WRANIFGENERICOBJ4,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_mibIEEE80222, 2,  { 9,4 }},
#define WRANIFGENERICOBJ5		25
{WRANIFGENERICOBJ5,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_mibIEEE80222, 2,  { 9,5 }},
#define WRANIFGENERICOBJ6		26
{WRANIFGENERICOBJ6,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_mibIEEE80222, 2,  { 9,6 }},
#define WRANIFGENERICOBJ7		27
{WRANIFGENERICOBJ7,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_mibIEEE80222, 2,  { 9,7 }},
#define WRANIFGENERICOBJ8		28
{WRANIFGENERICOBJ8,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_mibIEEE80222, 2,  { 9,8 }},

};
/*    (L = length of the oidsuffix) */


/** Initializes the mibIEEE80222 module */
void
init_mibIEEE80222(void)
{

    DEBUGMSGTL(("mibIEEE80222", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("mibIEEE80222", mibIEEE80222_variables, variable4,
               mibIEEE80222_variables_oid);

    /* place any other initialization junk you need here */
}

/*
 * var_mibIEEE80222():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_mibIEEE80222(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

    FILE *obj_file;                 // descritor de arquivo para meus objetos

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case WRANIFSMSSACHAVAILABILITYCHECKTIME:
        *write_method = write_wranIfSmSsaChAvailabilityCheckTime;
        memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfSmSsaChAvailabilityCheckTime", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case WRANIFSMSSANONOCCUPANCYPERIOD:
        *write_method = write_wranIfSmSsaNonOccupancyPeriod;
        memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfSmSsaNonOccupancyPeriod", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case WRANIFSMSSACHANNELOPENINGTXTIME:
        *write_method = write_wranIfSmSsaChannelOpeningTxTime;
        memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfSmSsaChannelOpeningTxTime", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case WRANIFSMMANAGEDCHANNEL:
        *write_method = write_wranIfSmManagedChannel;
        memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfSmManagedChannel", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case WRANIFSMMANAGEDCHANNELSTATUS:
      memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfSmManagedChannelStatus", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case WRANIFSMWRANOCCUPIEDCHANNELSET:
      memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfSmWranOccupiedChannelSet", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case WRANIFSSASENSINGCHANNEL:
        *write_method = write_wranIfSsaSensingChannel;
        memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfSsaSensingChannel", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case WRANIFSSATIMELASTSENSING:
      memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfSsaTimeLastSensing", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case WRANIFSSASENSINGPATHRSSI:
      memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfSsaSensingPathRssi", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case DECISIONOPERATINGCHANNEL:
      memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/DecisionOperatingChannel", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case DECISIONBACKUPCHANNEL:
      memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/DecisionBackupChannel", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case DECISIONCANDIDATECHANNELS:
      memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/DecisionCandidateChannels", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case DECISIONGAMAWEIGHT:
        *write_method = write_DecisionGamaWeight;
        memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/DecisionGamaWeight", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case DECISIONRSSIMINVALUE:
        *write_method = write_DecisionRssiMinValue;
        memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/DecisionRssiMinValue", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case DECISIONRSSIMAXVALUE:
        *write_method = write_DecisionRssiMaxValue;
        memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/DecisionRssiMaxValue", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case DECISIONUPLINKTHROUGHPUT:
      memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/DecisionDownlinkThroughput", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case DECISIONDOWNLINKTHROUGHPUT:
      memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/DecisionDownlinkThroughput", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case SHARINGSTARTTIME:
      memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/SharingStartTime", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case SHARINGSTOPTIME:
      memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/SharingStopTime", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case SHARINGALLOCATEDBAND:
      memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/SharingAllocatedBand", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case WRANIFGENERICOBJ1:
        *write_method = write_wranIfGenericObj1;
        memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfGenericObj1", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case WRANIFGENERICOBJ2:
        *write_method = write_wranIfGenericObj2;
        memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfGenericObj2", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case WRANIFGENERICOBJ3:
        *write_method = write_wranIfGenericObj3;
        memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfGenericObj3", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case WRANIFGENERICOBJ4:
        *write_method = write_wranIfGenericObj4;
        memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfGenericObj4", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case WRANIFGENERICOBJ5:
        *write_method = write_wranIfGenericObj5;
        memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfGenericObj5", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case WRANIFGENERICOBJ6:
        *write_method = write_wranIfGenericObj6;
        memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfGenericObj6", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case WRANIFGENERICOBJ7:
        *write_method = write_wranIfGenericObj7;
        memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfGenericObj7", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    case WRANIFGENERICOBJ8:
        *write_method = write_wranIfGenericObj8;
        memset(string, 0, sizeof(string));
        obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfGenericObj8", "r");
        fgets(string, sizeof(string), obj_file);
        *var_len = strlen(string);
        fclose(obj_file);
        return (u_char *) string;
    default:
      ERROR_MSG("Problems occured. Call Belo Leo\n");
    }
    return NULL;
}





int
write_wranIfSmSsaChAvailabilityCheckTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

	FILE *obj_file;                 // descritor de arquivo para meus objetos

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to mibIEEE80222 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          //if (var_val_len > sizeof(char)) { \\ comentada
	  	  if (var_val_len > 100) { // modificado para permitir tamanhos maiores
              fprintf(stderr,"write to mibIEEE80222: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	     	 system("rm /usr/local/etc/CrObjectsFiles/wranIfSmSsaChAvailabilityCheckTime");
             obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfSmSsaChAvailabilityCheckTime", "w+");
             fputs((char *)var_val, obj_file);
             memset(var_val, 0, sizeof(var_val));
             fclose(obj_file);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wranIfSmSsaNonOccupancyPeriod(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

	FILE *obj_file;                 // descritor de arquivo para meus objetos

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to mibIEEE80222 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          //if (var_val_len > sizeof(char)) { \\ comentada
	  	  if (var_val_len > 100) { // modificado para permitir tamanhos maiores
              fprintf(stderr,"write to mibIEEE80222: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	     	 system("rm /usr/local/etc/CrObjectsFiles/wranIfSmSsaNonOccupancyPeriod");
             obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfSmSsaNonOccupancyPeriod", "w+");
             fputs((char *)var_val, obj_file);
             memset(var_val, 0, sizeof(var_val));
             fclose(obj_file);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wranIfSmSsaChannelOpeningTxTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    FILE *obj_file;     // descritor de arquivo para escrita!

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to mibIEEE80222 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          //if (var_val_len > sizeof(char)) { comentada
	      if (var_val_len > 100) { // modificado para permitir tamanhos maiores
              fprintf(stderr,"write to mibIEEE80222: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	         system("rm /usr/local/etc/CrObjectsFiles/wranIfSmSsaChannelOpeningTxTime");
             obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfSmSsaChannelOpeningTxTime", "w+");
             fputs((char *)var_val, obj_file);
             memset(var_val, 0, sizeof(var_val));
             fclose(obj_file);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wranIfSmManagedChannel(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    FILE *obj_file;     // descritor de arquivo para escrita!

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to mibIEEE80222 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          //if (var_val_len > sizeof(char)) {
	  	  if (var_val_len > 100) { // modificado para permitir tamanhos maiores
              fprintf(stderr,"write to mibIEEE80222: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	         system("rm /usr/local/etc/CrObjectsFiles/wranIfSmManagedChannel");
             obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfSmManagedChannel", "w+");
             fputs((char *)var_val, obj_file);
             memset(var_val, 0, sizeof(var_val));
             fclose(obj_file);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wranIfSsaSensingChannel(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    FILE *obj_file;     // descritor de arquivo para escrita!

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to mibIEEE80222 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          //if (var_val_len > sizeof(char)) { comentada
	      if (var_val_len > 100) { // modificado para permitir tamanhos maiores
              fprintf(stderr,"write to mibIEEE80222: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	         system("rm /usr/local/etc/CrObjectsFiles/wranIfSsaSensingChannel");
             obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfSsaSensingChannel", "w+");
             fputs((char *)var_val, obj_file);
             memset(var_val, 0, sizeof(var_val));
             fclose(obj_file);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_DecisionGamaWeight(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    FILE *obj_file;     // descritor de arquivo para escrita!

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to mibIEEE80222 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          //if (var_val_len > sizeof(char)) { comentada
	      if (var_val_len > 100) { // modificado para permitir tamanhos maiores
              fprintf(stderr,"write to mibIEEE80222: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	         system("rm /usr/local/etc/CrObjectsFiles/DecisionGamaWeight");
             obj_file = fopen("/usr/local/etc/CrObjectsFiles/DecisionGamaWeight", "w+");
             fputs((char *)var_val, obj_file);
             memset(var_val, 0, sizeof(var_val));
             fclose(obj_file);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_DecisionRssiMinValue(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    FILE *obj_file;     // descritor de arquivo para escrita!

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to mibIEEE80222 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          //if (var_val_len > sizeof(char)) { comentada
	      if (var_val_len > 100) { // modificado para permitir tamanhos maiores
              fprintf(stderr,"write to mibIEEE80222: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	         system("rm /usr/local/etc/CrObjectsFiles/DecisionRssiMinValue");
             obj_file = fopen("/usr/local/etc/CrObjectsFiles/DecisionRssiMinValue", "w+");
             fputs((char *)var_val, obj_file);
             memset(var_val, 0, sizeof(var_val));
             fclose(obj_file);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_DecisionRssiMaxValue(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    FILE *obj_file;     // descritor de arquivo para escrita!

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to mibIEEE80222 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          //if (var_val_len > sizeof(char)) { comentada
	      if (var_val_len > 100) { // modificado para permitir tamanhos maiores
              fprintf(stderr,"write to mibIEEE80222: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	         system("rm /usr/local/etc/CrObjectsFiles/DecisionRssiMaxValue");
             obj_file = fopen("/usr/local/etc/CrObjectsFiles/DecisionRssiMaxValue", "w+");
             fputs((char *)var_val, obj_file);
             memset(var_val, 0, sizeof(var_val));
             fclose(obj_file);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wranIfGenericObj1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    FILE *obj_file;     // descritor de arquivo para escrita!

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to mibIEEE80222 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          //if (var_val_len > sizeof(char)) { comentada
	      if (var_val_len > 100) { // modificado para permitir tamanhos maiores
              fprintf(stderr,"write to mibIEEE80222: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	         system("rm /usr/local/etc/CrObjectsFiles/wranIfGenericObj1");
             obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfGenericObj1", "w+");
             fputs((char *)var_val, obj_file);
             memset(var_val, 0, sizeof(var_val));
             fclose(obj_file);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wranIfGenericObj2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    FILE *obj_file;     // descritor de arquivo para escrita!

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to mibIEEE80222 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          //if (var_val_len > sizeof(char)) { comentada
	      if (var_val_len > 100) { // modificado para permitir tamanhos maiores
              fprintf(stderr,"write to mibIEEE80222: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	         system("rm /usr/local/etc/CrObjectsFiles/wranIfGenericObj2");
             obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfGenericObj2", "w+");
             fputs((char *)var_val, obj_file);
             memset(var_val, 0, sizeof(var_val));
             fclose(obj_file);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wranIfGenericObj3(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    FILE *obj_file;     // descritor de arquivo para escrita!

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to mibIEEE80222 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          //if (var_val_len > sizeof(char)) { comentada
	      if (var_val_len > 100) { // modificado para permitir tamanhos maiores
              fprintf(stderr,"write to mibIEEE80222: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	         system("rm /usr/local/etc/CrObjectsFiles/wranIfGenericObj3");
             obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfGenericObj3", "w+");
             fputs((char *)var_val, obj_file);
             memset(var_val, 0, sizeof(var_val));
             fclose(obj_file);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wranIfGenericObj4(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    FILE *obj_file;     // descritor de arquivo para escrita!

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to mibIEEE80222 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          //if (var_val_len > sizeof(char)) { comentada
	      if (var_val_len > 100) { // modificado para permitir tamanhos maiores
              fprintf(stderr,"write to mibIEEE80222: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	         system("rm /usr/local/etc/CrObjectsFiles/wranIfGenericObj4");
             obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfGenericObj4", "w+");
             fputs((char *)var_val, obj_file);
             memset(var_val, 0, sizeof(var_val));
             fclose(obj_file);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wranIfGenericObj5(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    FILE *obj_file;     // descritor de arquivo para escrita!

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to mibIEEE80222 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          //if (var_val_len > sizeof(char)) { comentada
	      if (var_val_len > 100) { // modificado para permitir tamanhos maiores
              fprintf(stderr,"write to mibIEEE80222: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	         system("rm /usr/local/etc/CrObjectsFiles/wranIfGenericObj5");
             obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfGenericObj5", "w+");
             fputs((char *)var_val, obj_file);
             memset(var_val, 0, sizeof(var_val));
             fclose(obj_file);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wranIfGenericObj6(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    FILE *obj_file;     // descritor de arquivo para escrita!

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to mibIEEE80222 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          //if (var_val_len > sizeof(char)) { comentada
	      if (var_val_len > 100) { // modificado para permitir tamanhos maiores
              fprintf(stderr,"write to mibIEEE80222: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	         system("rm /usr/local/etc/CrObjectsFiles/wranIfGenericObj6");
             obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfGenericObj6", "w+");
             fputs((char *)var_val, obj_file);
             memset(var_val, 0, sizeof(var_val));
             fclose(obj_file);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wranIfGenericObj7(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    FILE *obj_file;     // descritor de arquivo para escrita!

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to mibIEEE80222 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          //if (var_val_len > sizeof(char)) { comentada
	      if (var_val_len > 100) { // modificado para permitir tamanhos maiores
              fprintf(stderr,"write to mibIEEE80222: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	         system("rm /usr/local/etc/CrObjectsFiles/wranIfGenericObj7");
             obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfGenericObj7", "w+");
             fputs((char *)var_val, obj_file);
             memset(var_val, 0, sizeof(var_val));
             fclose(obj_file);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wranIfGenericObj8(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    FILE *obj_file;     // descritor de arquivo para escrita!

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to mibIEEE80222 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          //if (var_val_len > sizeof(char)) { comentada
	      if (var_val_len > 100) { // modificado para permitir tamanhos maiores
              fprintf(stderr,"write to mibIEEE80222: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	         system("rm /usr/local/etc/CrObjectsFiles/wranIfGenericObj8");
             obj_file = fopen("/usr/local/etc/CrObjectsFiles/wranIfGenericObj8", "w+");
             fputs((char *)var_val, obj_file);
             memset(var_val, 0, sizeof(var_val));
             fclose(obj_file);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

